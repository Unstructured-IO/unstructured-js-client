/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as b64$ from "../../../lib/base64";
import { blobLikeSchema } from "../../types";
import * as z from "zod";

export type Files = {
    content: Uint8Array | string;
    fileName: string;
};

export type PartitionParameters = {
    /**
     * Use one of the supported strategies to chunk the returned elements. Currently supports: by_title
     */
    chunkingStrategy?: string | undefined;
    /**
     * If chunking strategy is set, combine elements until a section reaches a length of n chars. Default: max_characters
     */
    combineUnderNChars?: number | undefined;
    /**
     * If true, return coordinates for each element. Default: false
     */
    coordinates?: boolean | undefined;
    /**
     * The encoding method used to decode the text input. Default: utf-8
     */
    encoding?: string | undefined;
    /**
     * The types of elements to extract, for use in extracting image blocks as base64 encoded data stored in metadata fields
     */
    extractImageBlockTypes?: Array<string> | undefined;
    /**
     * The file to extract
     */
    files?: Files | Blob | undefined;
    /**
     * If file is gzipped, use this content type after unzipping
     */
    gzUncompressedContentType?: string | undefined;
    /**
     * The name of the inference model used when strategy is hi_res
     */
    hiResModelName?: string | undefined;
    /**
     * When True (the default), the elements used to form a chunk appear in `.metadata.orig_elements` for that chunk. Only applies when chunking is specified using the `chunking_strategy` argument.
     */
    includeOrigElements?: boolean | undefined;
    /**
     * If True, the output will include page breaks if the filetype supports it. Default: false
     */
    includePageBreaks?: boolean | undefined;
    /**
     * The languages present in the document, for use in partitioning and/or OCR
     */
    languages?: Array<string> | undefined;
    /**
     * If chunking strategy is set, cut off new sections after reaching a length of n chars (hard max). Default: 500
     */
    maxCharacters?: number | undefined;
    /**
     * If chunking strategy is set, determines if sections can span multiple pages. Only applies to by_title chunking strategy.Default: true
     */
    multipageSections?: boolean | undefined;
    /**
     * If chunking strategy is set, cut off new sections after reaching a length of n chars (soft max). Default: max_characters (off)
     */
    newAfterNChars?: number | undefined;
    /**
     * The format of the response. Supported formats are application/json and text/csv. Default: application/json.
     */
    outputFormat?: string | undefined;
    /**
     * A prefix of this many trailing characters from the prior text-split chunk is applied to second and later chunks formed from oversized elements by text-splitting. Default: None
     */
    overlap?: number | undefined;
    /**
     * When True, overlap is also applied to 'normal' chunks formed by combining whole elements. Use with caution as this can introduce noise into otherwise clean semantic units. Default: None
     */
    overlapAll?: boolean | undefined;
    /**
     * If True and strategy=hi_res, any Table Elements extracted from a PDF will include an additional metadata field, 'text_as_html', where the value (string) is a just a transformation of the data into an HTML <table>.
     */
    pdfInferTableStructure?: boolean | undefined;
    /**
     * The document types that you want to skip table extraction with. Default: ['pdf', 'jpg', 'png']
     */
    skipInferTableTypes?: Array<string> | undefined;
    /**
     * Should the pdf file be split at client. Ignored on backend.
     */
    splitPdfPage?: boolean | undefined;
    /**
     * The strategy to use for partitioning PDF/image. Options are fast, hi_res, auto. Default: auto
     */
    strategy?: string | undefined;
    /**
     * When True, assign UUIDs to element IDs, which guarantees their uniqueness (useful when using them as primary keys in database). Otherwise a SHA-256 of element text is used. Default: False
     */
    uniqueElementIds?: boolean | undefined;
    /**
     * If True, will retain the XML tags in the output. Otherwise it will simply extract the text from within the tags. Only applies to partition_xml.
     */
    xmlKeepTags?: boolean | undefined;
};

/** @internal */
export namespace Files$ {
    export type Inbound = {
        content: Uint8Array | string;
        fileName: string;
    };

    export const inboundSchema: z.ZodType<Files, z.ZodTypeDef, Inbound> = z
        .object({
            content: b64$.zodInbound,
            fileName: z.string(),
        })
        .transform((v) => {
            return {
                content: v.content,
                fileName: v.fileName,
            };
        });

    export type Outbound = {
        content: Uint8Array;
        fileName: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Files> = z
        .object({
            content: b64$.zodOutbound,
            fileName: z.string(),
        })
        .transform((v) => {
            return {
                content: v.content,
                fileName: v.fileName,
            };
        });
}

/** @internal */
export namespace PartitionParameters$ {
    export type Inbound = {
        chunking_strategy?: string | undefined;
        combine_under_n_chars?: number | undefined;
        coordinates?: boolean | undefined;
        encoding?: string | undefined;
        extract_image_block_types?: Array<string> | undefined;
        files?: Files$.Inbound | undefined;
        gz_uncompressed_content_type?: string | undefined;
        hi_res_model_name?: string | undefined;
        include_orig_elements?: boolean | undefined;
        include_page_breaks?: boolean | undefined;
        languages?: Array<string> | undefined;
        max_characters?: number | undefined;
        multipage_sections?: boolean | undefined;
        new_after_n_chars?: number | undefined;
        output_format?: string | undefined;
        overlap?: number | undefined;
        overlap_all?: boolean | undefined;
        pdf_infer_table_structure?: boolean | undefined;
        skip_infer_table_types?: Array<string> | undefined;
        split_pdf_page?: boolean | undefined;
        strategy?: string | undefined;
        unique_element_ids?: boolean | undefined;
        xml_keep_tags?: boolean | undefined;
    };

    export const inboundSchema: z.ZodType<PartitionParameters, z.ZodTypeDef, Inbound> = z
        .object({
            chunking_strategy: z.string().optional(),
            combine_under_n_chars: z.number().int().optional(),
            coordinates: z.boolean().optional(),
            encoding: z.string().optional(),
            extract_image_block_types: z.array(z.string()).optional(),
            files: z.lazy(() => Files$.inboundSchema).optional(),
            gz_uncompressed_content_type: z.string().optional(),
            hi_res_model_name: z.string().optional(),
            include_orig_elements: z.boolean().optional(),
            include_page_breaks: z.boolean().optional(),
            languages: z.array(z.string()).optional(),
            max_characters: z.number().int().optional(),
            multipage_sections: z.boolean().optional(),
            new_after_n_chars: z.number().int().optional(),
            output_format: z.string().optional(),
            overlap: z.number().int().optional(),
            overlap_all: z.boolean().optional(),
            pdf_infer_table_structure: z.boolean().optional(),
            skip_infer_table_types: z.array(z.string()).optional(),
            split_pdf_page: z.boolean().optional(),
            strategy: z.string().optional(),
            unique_element_ids: z.boolean().optional(),
            xml_keep_tags: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                ...(v.chunking_strategy === undefined
                    ? null
                    : { chunkingStrategy: v.chunking_strategy }),
                ...(v.combine_under_n_chars === undefined
                    ? null
                    : { combineUnderNChars: v.combine_under_n_chars }),
                ...(v.coordinates === undefined ? null : { coordinates: v.coordinates }),
                ...(v.encoding === undefined ? null : { encoding: v.encoding }),
                ...(v.extract_image_block_types === undefined
                    ? null
                    : { extractImageBlockTypes: v.extract_image_block_types }),
                ...(v.files === undefined ? null : { files: v.files }),
                ...(v.gz_uncompressed_content_type === undefined
                    ? null
                    : { gzUncompressedContentType: v.gz_uncompressed_content_type }),
                ...(v.hi_res_model_name === undefined
                    ? null
                    : { hiResModelName: v.hi_res_model_name }),
                ...(v.include_orig_elements === undefined
                    ? null
                    : { includeOrigElements: v.include_orig_elements }),
                ...(v.include_page_breaks === undefined
                    ? null
                    : { includePageBreaks: v.include_page_breaks }),
                ...(v.languages === undefined ? null : { languages: v.languages }),
                ...(v.max_characters === undefined ? null : { maxCharacters: v.max_characters }),
                ...(v.multipage_sections === undefined
                    ? null
                    : { multipageSections: v.multipage_sections }),
                ...(v.new_after_n_chars === undefined
                    ? null
                    : { newAfterNChars: v.new_after_n_chars }),
                ...(v.output_format === undefined ? null : { outputFormat: v.output_format }),
                ...(v.overlap === undefined ? null : { overlap: v.overlap }),
                ...(v.overlap_all === undefined ? null : { overlapAll: v.overlap_all }),
                ...(v.pdf_infer_table_structure === undefined
                    ? null
                    : { pdfInferTableStructure: v.pdf_infer_table_structure }),
                ...(v.skip_infer_table_types === undefined
                    ? null
                    : { skipInferTableTypes: v.skip_infer_table_types }),
                ...(v.split_pdf_page === undefined ? null : { splitPdfPage: v.split_pdf_page }),
                ...(v.strategy === undefined ? null : { strategy: v.strategy }),
                ...(v.unique_element_ids === undefined
                    ? null
                    : { uniqueElementIds: v.unique_element_ids }),
                ...(v.xml_keep_tags === undefined ? null : { xmlKeepTags: v.xml_keep_tags }),
            };
        });

    export type Outbound = {
        chunking_strategy?: string | undefined;
        combine_under_n_chars?: number | undefined;
        coordinates?: boolean | undefined;
        encoding?: string | undefined;
        extract_image_block_types?: Array<string> | undefined;
        files?: Files$.Outbound | Blob | undefined;
        gz_uncompressed_content_type?: string | undefined;
        hi_res_model_name?: string | undefined;
        include_orig_elements?: boolean | undefined;
        include_page_breaks?: boolean | undefined;
        languages?: Array<string> | undefined;
        max_characters?: number | undefined;
        multipage_sections?: boolean | undefined;
        new_after_n_chars?: number | undefined;
        output_format?: string | undefined;
        overlap?: number | undefined;
        overlap_all?: boolean | undefined;
        pdf_infer_table_structure?: boolean | undefined;
        skip_infer_table_types?: Array<string> | undefined;
        split_pdf_page?: boolean | undefined;
        strategy?: string | undefined;
        unique_element_ids?: boolean | undefined;
        xml_keep_tags?: boolean | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PartitionParameters> = z
        .object({
            chunkingStrategy: z.string().optional(),
            combineUnderNChars: z.number().int().optional(),
            coordinates: z.boolean().optional(),
            encoding: z.string().optional(),
            extractImageBlockTypes: z.array(z.string()).optional(),
            files: z
                .lazy(() => Files$.outboundSchema)
                .or(blobLikeSchema)
                .optional(),
            gzUncompressedContentType: z.string().optional(),
            hiResModelName: z.string().optional(),
            includeOrigElements: z.boolean().optional(),
            includePageBreaks: z.boolean().optional(),
            languages: z.array(z.string()).optional(),
            maxCharacters: z.number().int().optional(),
            multipageSections: z.boolean().optional(),
            newAfterNChars: z.number().int().optional(),
            outputFormat: z.string().optional(),
            overlap: z.number().int().optional(),
            overlapAll: z.boolean().optional(),
            pdfInferTableStructure: z.boolean().optional(),
            skipInferTableTypes: z.array(z.string()).optional(),
            splitPdfPage: z.boolean().optional(),
            strategy: z.string().optional(),
            uniqueElementIds: z.boolean().optional(),
            xmlKeepTags: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                ...(v.chunkingStrategy === undefined
                    ? null
                    : { chunking_strategy: v.chunkingStrategy }),
                ...(v.combineUnderNChars === undefined
                    ? null
                    : { combine_under_n_chars: v.combineUnderNChars }),
                ...(v.coordinates === undefined ? null : { coordinates: v.coordinates }),
                ...(v.encoding === undefined ? null : { encoding: v.encoding }),
                ...(v.extractImageBlockTypes === undefined
                    ? null
                    : { extract_image_block_types: v.extractImageBlockTypes }),
                ...(v.files === undefined ? null : { files: v.files }),
                ...(v.gzUncompressedContentType === undefined
                    ? null
                    : { gz_uncompressed_content_type: v.gzUncompressedContentType }),
                ...(v.hiResModelName === undefined
                    ? null
                    : { hi_res_model_name: v.hiResModelName }),
                ...(v.includeOrigElements === undefined
                    ? null
                    : { include_orig_elements: v.includeOrigElements }),
                ...(v.includePageBreaks === undefined
                    ? null
                    : { include_page_breaks: v.includePageBreaks }),
                ...(v.languages === undefined ? null : { languages: v.languages }),
                ...(v.maxCharacters === undefined ? null : { max_characters: v.maxCharacters }),
                ...(v.multipageSections === undefined
                    ? null
                    : { multipage_sections: v.multipageSections }),
                ...(v.newAfterNChars === undefined
                    ? null
                    : { new_after_n_chars: v.newAfterNChars }),
                ...(v.outputFormat === undefined ? null : { output_format: v.outputFormat }),
                ...(v.overlap === undefined ? null : { overlap: v.overlap }),
                ...(v.overlapAll === undefined ? null : { overlap_all: v.overlapAll }),
                ...(v.pdfInferTableStructure === undefined
                    ? null
                    : { pdf_infer_table_structure: v.pdfInferTableStructure }),
                ...(v.skipInferTableTypes === undefined
                    ? null
                    : { skip_infer_table_types: v.skipInferTableTypes }),
                ...(v.splitPdfPage === undefined ? null : { split_pdf_page: v.splitPdfPage }),
                ...(v.strategy === undefined ? null : { strategy: v.strategy }),
                ...(v.uniqueElementIds === undefined
                    ? null
                    : { unique_element_ids: v.uniqueElementIds }),
                ...(v.xmlKeepTags === undefined ? null : { xml_keep_tags: v.xmlKeepTags }),
            };
        });
}
